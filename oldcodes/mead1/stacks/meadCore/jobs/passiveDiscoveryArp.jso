const { HotspringJob } = require('hotspring-framework');

class PassiveDiscoveryArp extends HotspringJob {
    static jobTemplateName = 'passiveDiscoveryArp';
    static jobTemplateType = 'service';
    static description = 'Collects ARP Data discovered using pcap';

    static defaultConfiguration = {
        instanceName: {type: 'string', default: 'general', description: "The name of the instance"},
        createHostFromSender: document.getElementById('createFromSender').checked,
        createHostFromResponse: document.getElementById('createFromResponse').checked,
        location: document.getElementById('locationSelect').value,
        nativeVlan: 1,
        arpUploadInterval: 60, // Flush logs every 60 seconds
        arpConsolidationInterval: 60, // Consolidate logs every 60 seconds
        createVLan: "Per-Organization"
    }

    static supportsPause = true;
    static supportsCancel = true;
    static supportsUndo = false;

    rotateInProgress = false;
    lastUploadTime = null;
    

    
    vlanList = [];
    deviceList = [];
    arpList = [];

    constructor(config) {
        super(config);
    }
    async runJob(config) {
        //I'm not sure it makes sense to pass a config here.
        const { Syslogd }  = require('../syslog');
        const server = new Syslogd();
        server.startListening();
        await this.nextBatch(); //Cycle the batch. This should clean up any old batches and start a new one.
        server.on('message', async (value) => {
            //Wait for the rotation to complete if it is in progress. This goes quick.
            while (this.rotateInProgress) {                
                await new Promise((resolve) => setTimeout(resolve, 10));
            }
            //If the host is not in the message queue, add it.
            if (!this.queuedMessagesByHost[value.sourceIP]) 
                this.queuedMessagesByHost[value.sourceIP] = [];
            //Add the message to the queue.
            this.queuedMessagesByHost[value.sourceIP].push(value);
        });
        server.on('error', (err) => {
            console.error(err);
        });

        this.flushTrigger = setInterval(this.flushLogs.bind(this), this.config.logFlushInterval * 1000);

        console.log('Syslog Collector Started with logFlushInterval:', this.config.logFlushInterval);
    }
    async flushLogs() {
        //This commits the logs to the database or file under the current batch.
        //If there is no current batch, it starts a new one.

        //First rotate the log.
        this.rotateInProgress = true;
        let processingQueue = this.queuedMessagesByHost;
        this.queuedMessagesByHost = {};
        this.rotateInProgress = false;

        //Check if we need to rotate the batch.
        if (this.config.logBatchInterval !== 0) {
            const now = Date.now();
            if (!this.lastBatchTime || (now - this.lastBatchTime) >= this.config.logBatchInterval * 1000) {
                await this.nextBatch(); // Call nextBatch if the interval has elapsed
                this.lastBatchTime = now; // Update the last batch timestamp
            }
        }
        
        const deviceModel =  this.hotspring.stacks['network'].models['device'];
        
        //Upload the information to the current batch. This does it by host so that it can also process the data if possible.
        let hosts = {};
        let devIDs = {};
        let hostProcessor = {};

        //Loop through the hosts listed in the processing Queue.
        for (const host in processingQueue) {
            //If the host is not in the host list, add it.
            hosts[host] = {};
            if (!devIDs[host]) {
                if (host.includes(".")) {
                    let hostObject = await deviceModel.findHostByAddress(host, "IPv4");
                    if (!hostObject) {
                        hostObject = await deviceModel.createHost({ baseIPv4: host })
                    }
                    devIDs[host]=hostObject.deviceID;
                    hostProcessor[host]='raw';
                } else {
                    //Assuming IPv6                    
                    let hostObject = await deviceModel.findHostByAddress(host, "IPv6");
                    if (!hostObject) {
                        hostObject = await deviceModel.createHost({ baseIPv6: host })
                    }
                    devIDs[host]=hostObject.deviceID;
                    hostProcessor[host]='raw';
                }


            }

            
            //Get the Host parameters from the model. SyslogProcessor and SyslogProcessorConfig. (These could be arrays)
            //If the host is not in the model, create it with the Generic Processor.

            //Loop through the messages for the host.
            let entries = [];
            let messages = [];
            let data = [];
            for (const message of processingQueue[host]) {
                //For each message, process it with the processor if one is defined and exists on this agent.
                entries.push({
                    batchID: this.currentBatchID,
                    logEntryID: null,
                    lineID: this.currentLine++,
                    deviceID: devIDs[host],
                    facility: message.facility,
                    severity: message.severity,
                    time: message.time,
                    message: message.msg,
                    state: 2 //Unprocessed
                });
                
                //If successfully processed, set the logEntry to processed.
                //This will need modification when we implement distributed agents.
                //console.log(message);
                //Upload the message to the database using logentry sequelize Model.
                //Process the message with the processor.
                //Flag the message as processed.
            }
            //Bulk Upload the Syslog Entries
            const logEntryModel = await this.hotspring.stacks['syslog'].models['logentry'];                
            const logEntries = await logEntryModel.sequelizeObject.bulkCreate(entries, { fields: ['batchID', 'deviceID', 'facility', 'severity', 'time', 'state'], returning: true });
            for (let i = 0;i<entries.length;i++) {
                entries[i].logEntryID=logEntries[i].dataValues.logEntryID;
            }
            


            const logEntryMessageModel = await this.hotspring.stacks['syslog'].models['logentrymessage'];                
            await logEntryMessageModel.sequelizeObject.bulkCreate(entries, { fields: ['logEntryID', 'message'] });

            console.log('Host:', host, 'Messages:', processingQueue[host].length, ' added to Database.');
        }        
    }

    async nextBatch() {
        //The logger should move to the next batch after X seconds or by a trigger in the database.
        if (this.currentBatchID > 0) {
            // Update the current batch state to "Unprocessed"
            await this.updateBatchState(this.currentBatchID, 2, {
                totalLines: this.currentLine-1,
                batchEndTime: new Date()
            });
        }

        // Start a new batch
        const newBatch = await this.createLogBatch();
        this.currentBatchID = newBatch.batchID;
        this.currentLine = 1;        
        newBatch.state = 1; // Active
        newBatch.sourceDeviceID = 0; // Will be updated later to use our agent id
        newBatch.batchStartTime = new Date();
        this.lastBatchTime = newBatch.batchStartTime ; // Update the last batch timestamp
    }

    async updateBatchState(batchID, state, updates) {
        // Update the batch state in the database
        const model = this.hotspring.stacks['syslog'].models['logbatch'];
        await model.editObject({
            batchID,
            state,
            ...updates
        });
    }

    async createLogBatch() {
        // Create a new log batch record in the database
        const model = this.hotspring.stacks['syslog'].models['logbatch'];
        const newBatch = await model.addObject({
            state: 1, // Active
            collectorID: this.hotspring.coordinatorHost.deviceID, // Will be updated later to use our agent id
            collectorIP: "0.0.0.0",
            batchStartTime: new Date()
        });
        return newBatch.dataValues;
    }
}

module.exports = SyslogCollector;




//ffffffffffff - Dest MAC
//00090f09001a - Source MAC
//8100 - VLAN
//0011 - VLAN 17
//0806 - Arp

//Arp Packet
//0001 - Hardware Type
//0800 - IPv4
//06 - Hardware Length (MAC Length)
//04 - Protocol Length (IP Length)
//0001 - Operation
//00090f09001a - Sender Hardware Address
//0a110101 - Sender Protocol Address
//000000000000 - Target Hardware Address
//0a11 - Target Protocol Address
//01910000 - CRC

console.log("Found ");

import cap from 'cap';
const Cap = cap.Cap;

class arpListener {
    ifName = '';
    captureInterface = null;
    async startListening(ifName) {
        
        //const device = cap.findDevice(ifName);
        //if (!device) throw new Error(`PCAP device for interface ${ifName} not found`);
        //console.log(device)
        this.ifName=ifName;

        const bufSize = 10 * 1024 * 1024;
        const buffer = Buffer.alloc(65535);

        const captureInterface = new Cap();
        if (!captureInterface) throw new Error(`PCAP device for interface ${ifName} not found`);
        const linkType = captureInterface.open(ifName, 'arp', bufSize, buffer);
        if (captureInterface.setMinBytes) captureInterface.setMinBytes(0);

        // Listen for ARP replies
        captureInterface.on('packet', (nbytes, truncated) => {
          const pkt = Buffer.from(buffer.slice(0, nbytes)); // Copy for safety
            packetQueue.push(pkt);
        });


        //Class ARP 
, nbytes => {
            if (linkType !== 'ETHERNET') return;
			//Ethernet Packet
            let curByte = 0;
			//ffffffffffff - Dest MAC
            const destMac = bufferToMAC(buffer.subarray(curByte, curByte+6));
            curByte+=6;
			//00090f09001a - Source MAC
            const srcMac = bufferToMAC(buffer.subarray(curByte, curByte+6));
            curByte+=6;
            
            let etherType = buffer.readUInt16BE(curByte);
            curByte+=2

            let vlan=0;
            if (etherType == 0x8100) {
                vlan = buffer.readUInt16BE(curByte);
                curByte+=2
                etherType = buffer.readUInt16BE(curByte);
                curByte+=2
            }
            if (!vlan) return;
            if (etherType !== 0x0806) return; // Not ARP
            //console.log({destMac,srcMac,etherType,vlan});

            const opcode = buffer.readUInt16BE(20);
            //if (opcode !== 2) return; // Not a reply

            const senderMAC = bufferToMAC(buffer.subarray(22, 28));
            const senderIP = bufferToIP(buffer.subarray(28, 32));

            //addResult(senderIP, senderMAC);
            //console.log("Found " + senderIP + " at " + senderMAC + "on VLAN" + vlan);
            console.log(buffer.subarray(0,48).toString('hex'));
        });


    }
}
function bufferToIP(buf, curByte) {
  return [...buf].join('.');
}

function bufferToMAC(buf, curByte) {
  return [...buf].map(b => b.toString(16).padStart(2, '0')).join(':');
}

let test = new arpListener();
test.startListening('eth1');

        // // Result structure: { ip: string => { macs: Set<string>, timestamps: [Date], conflict: boolean } }
        // const results = new Map();

        // function addResult(ip, mac) {
        //     let r = results.get(ip);
        //     if (!r) {
        //         r = { macs: new Set(), timestamps: [], conflict: false };
        //         results.set(ip, r);
        //     }
        //     r.macs.add(mac);
        //     r.timestamps.push(new Date());
        //     r.conflict = r.macs.size > 1;
        // }

